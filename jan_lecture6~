			Ян. Лекция 6. Читаем man по сигналам вместе с Яном.

Задание:  читаем man 7 signal и для каждого параграфа выписываем
* основные поинты
* структуры ядра

Сигналы - типа сообщения процессу
У каждого сигнала есть контракт(disposition) - определяет, что процесс делает, когда к нему приходит определённый сигнал
Для каждого сигнала есть дефолтное поведение:
Term - убить процесс
Ign - ничего не делать
Core - убить процесс и сделать дамп ядра
Stop - остановить процесс
Cont - продолжить выполнение процесса, если он остановлен

Процесс может менять контракт сигнала - закладывать в него адрес функции, которую необходимо выполнить, когда сигнал доставлен.
Контракт сигнала локальное для процесса, и для всех тредов этого процесса одинаковое.
При форке наследуется копия списка контрактов сигналов.

Есть набор команд чтобы отправлять сигналы, в мане написаны.
Есть 2 команды, чтобы приостановить процесс и ждать сигнала.
Сигналы можно ждать как синхронно, так и асинхронно.

//это было то, что успел начитать, дальше вещает Ян

"Сигнал - это такая палка, которой тыкают процесс. У каждого процесса есть 32 мягких места, в которые можно пнуть ногой"
SigDisposition : map {signal->disposition}
Disp = ....|...|Action
Action = Default|Ignored|Handler;
Default = Term|Ign|...|Cont
Handler: *(int -> sa->())-- custom handler-- 
Есть sigaction() чтобы тюнить сигналы(ставить кастомные обработчики). В man для sigaction всё написано.

ProcInfo = {
....,
sigPending:: Int
sigDisp:: SigDisposition 
}

fork:
	copy sigdisp

exec:
	\forall sig: sgidisp do Handler -> Default


Сигналы бывают двух типов: Real-Time и Standard/Regular
Signals = Regular|Real-Time

Важный раздел: про Signal Masks и Pending
Сигнал может быть заблокирован.
Pending - состояние сигнала, между его созданием и доставкой.
У каждого треда есть независимая sigmask, которая определяет, какие сигналы текущий тред блокирует.
sigmask наследуется копией при форке.

Сигнал может быть сгенерирован для всего процесса и для отдельного треда.
То есть, существует 
ThreadInfo  = {
....
sigDisp::SigDisposition
sigMask::SigMask
sigPending::Int/set
sigRTPending::int/multiset based on queue
}
signum->[value]

Есть sigpending() - возвращает множество сигналов, которые сейчас ждут(pending)
returns sigset_t

Исключения в процессоре реализованы interruptами, почитать про это надо. 
 А сигналы вроде SIGILL, SIGFPE - юниксовая обёртка над этими интерраптами.

Прочитать man 7 signal полностью!

Если процессу посланы два одинаковых сигнала одни сливаются. А Real-time сигналы встают в очередь.

Как это всё реально эффективно реализовано?
ProcInfo ={
sigign: Word
sigrtign: Word
sigmask: Word
sigRTMask: Word
sigDisp:: signum -> Default|Handler *(...)
sigPending: Word
sigRtPending: Map{signum-> Queue<Int>}
}

disposition и sigign - логически имеют один тип.
ThreadInfo{
sig(rt)Mask:-||-
sig(rt)Pending:-||-
}

context switch(process):
	c= process.sigpending & process.sigmask
	if(c!=0)
		handle_these_signals(c)
	else
		jmp process.pip

kill(pid,signum):
	process = get_process(pid);
	process.sigpending |= (1<<(signum-1)) & process.sigign
	return back to kill caller

tgkill(tid,signum):
	&thread = get_thread(tid);
	thread.sigpending |= (1<<(signum-1)) & process.sigign
	return back to kill caller

Сигналы можно условно разделить на три больших группы:
Hardware Interrupts - просто интеррапты, некоторые из которых маппятся в сигналы
OS Events - SIGCHILD, SIGHUB, USR - чисто юниксовые штуки
SIGKILL & SIGSTOP - вообще не являются сигналами, отсутствуют везде. По логике должны сделать были бы отдельные системные выовы.
SIGCONT - процесс понимает, что его восстановили, в отличие от ситуации, когда его 

Прерывание сигналаими.
Погулить про реинтерабельность.
Системные вызовы в юниксе могут прерываться сигналами. А могут не прерываться.

У процесса есть 4 состояния: три нормальных: W(работает), R(готов), S(спит) и одно странное: I(ininterruptable) - 
когда процесс нельзя убить потому что он не находится ни в одной из очередей а что-то считает.
(например, умирающий винчестер очень долго пытается прочесть битый блок)
поэтому kill(9) может не сразу убить процесс.

Как обрабатывать сигналы:
все обработчики сигналов по стандарту умеют работать только с глобальным переменными типа
sigatomic_t

Если есть программа, которая делает цикл - 
иногда в пцикле проверяешь, стоит ли флаг sigatomic_t в нуле. Если 1 - то надо завершиться.

Обычно по дефолту сигналы просто крешат программу. Чтобы такого не было - надо делать вышеописанное, чтобы не было несогласованных
состояний на диске. sigatomic_t - просто int, на самом деле, но по стандарту так называется.

Второй вариант:
в начале программы сделать пайп, а потом настроить обработчики , так, чтобы они писали в этот пайп.(например, номер сигнала),
а с другого конца(внутри программы) мы просто читаем из этого пайпа, навроде сервер - клиент. Популярная штука в boost.

sigwait
sigpending - берём и блокируем все сигналы.  после этого иногда смотрим на sigpending и если что-то видим - то  обрабатываем.
kill и stop - не сигналы, у них интерфейс посылки как у сигнала, но ловить как сигналы их мы не можем.







































