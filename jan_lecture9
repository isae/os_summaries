				Ян. Лекция 9.

Работа с сетью в экзоядерных ОС.

Устройства с точки зрения таких ОС делится на память и CPU.
Сеть относится к CPU.

Мораль: есть очередь пакетов из сети, которые валятся и нам нужно разобраться какой программе какой пакет отдал.
Как сеть устроена?  Есть общая шина: 8 проводов, половина на вход, половина на выход - Ethernet,
на ней висят компьютеры. Если один из них хочет сообщить что-то другому - ждёт пока не говорит никто другой, начинает что-то говорить и слушать это  - и если это не совпадает, то начинает кричать "паника". И все кто слышат "паника" - все затыкаются.
Алгоритм "семьи за обеденным столом".

Ethernet-адреса MAC.
В ethernet есть встроенный протокол с подтверждениями, но им никто не пользуется.
Компьютеры шлют друг-другу пакеты вида
-от кого (MAC)
-кому (MAC)
-данные 

без подтверждения. Максимум длины пакета - 1500 байт памяти.
Операционные системы об этом уровне стараются не задумываться. Большинство современных ОС работает на уровне выше - IP, или даже на TCP.
Ниже - геморрой.

Пакет в протоколе очень похож на Ethernet
-from
-to
-flags
-checksum of header
-data
Примерно всё API построено вокруг этого IP - протокола.
Интернет - прошитое дерево.
Есть набор интерфейсов(сетевых кард), у каждой есть айпи-адрес и маска подсети. 
192.168.0.16/24
255.255.255.0 - сначала единицы а потом нули
Когда хотим послать пакет - матчим его по маске и смотрим, если единицы совпадают - отправляем //почитать, Ян слишком быстро трещал тут
Default Gateway - айпи адрес, на который надо отправить пакет, если протокол не знает, куда его отправить. (но в поле to должен быть адрес, на который мы хотели отправить), чтобы он разбирался сам с этим пакетом.
Так продолжается до самого верха до ребят,у которого нет Default Gateway, но есть доступ ко всем интерфейсам - корневые маршрутизаторы.

UDP - это то же самое, что IP, но вместо MAC - IP - адреса.

С точки зрения ОС:
-нам пришёл IP - пакет, есть несколько программ, кому отдать?
Raw-socket.
Есть socket(), который выдаёт файловый дескриптор на сокет.
Есть системный вызов bind, который может рулить открытым сокетом(типа файл). Мы ему кормим почти регулярное выражение, на самом деле фильтр, который определяет, писать определённые пакеты или нет.

В ядре есть очередь, на которую от всех интерфейсов падают пакеты. Есть firewall-ы, которые могут перебрасывать пакеты.
Что происходит? Сокет, который забиндован на raw - сокет - представляет собой просто указатель в этой очереди. У очереди много голов и каждая голова - это fdobj raw-сокета.

Когда делаем read - просто пакет из головы читаем в память и двигаем голову. Если не помещается - обрезаем.
RAW - сокет может создавать только root.


TCP - сокет. тип сокета указывается в bind().
У TCP есть порт - ещё один под-адрес, в сущности адрес программы на машине. TCP - socket занимается ровно тем, чтофильтрует пакеты, у которых порт такой, который нам нужно.

TCP - по сути просто пайп между двумя машинами.
sport // siurce port
dport //dest port
Три варианта развития событий:
-создали сокет
--хотим соединиться с кем-то
-- ждём содинения

connect(IP,port)

//MAN!!!

Datagram - socket

Стек протоколов:
PHYSICAL
Ethernet
IP
TCP/UDP/SCTP/ICMP
HTTP/DNS/FTP/SSH/IPTEL
Web-socket

Сделали socket(), дали объект. Задача - вклиниться в нужное место в этой иерархии и если место, в которое вклинились подразумевает какой-то фильтр - то придумать, как фильтровать.






























