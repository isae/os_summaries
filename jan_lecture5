							Ян. Лекция 5. Контрольная.

Интересная файловая система: древовидная,живёт в памяти ядра, есть два типа именованных файлов:
1. pipe
2. dev(девайс),[blocks](массив блоков)

mknode("foo/file",pipe); - вот такой системный вызов для создания файлов
mknode("foo/file", Dev(id,[block]))

"кто-то заполнил для нас файловую систему"

open("путь для чтения", R/W) - и после такого открытия можно уже дёргать:
read(fd, ____,___);
write(fd,buf,length);
close(fd);

-- нужно реализовать эти 4 вызова

+ прерывания

timer - "слишком долго работаем, прошло 10 мс"
HDD - "девайс выполнил последнюю операцию"

pipe - просто адрес ring-буфера в ядре. 
inode{
type = pipe
adress:: int	}


Есть IO-порты, есть till-ready(дожидается, пока порт будет готов)
IOPort->(id, R/W, block(блок на девайсе), memory_block(блок в памяти));


требуется - реализовать в такой файловой системе

для винчестера есть очередь с запросами. По прерыванию мы достаём следующее сообщщение и посылаем его на винчестер.
В ядре сообщение в очереди это {"суть", список подписчиков - кого пнуть, когда оно выполнится}.
write(fd, buf, длина)
	если buf<длина - тогда просто посылаем сообщение на винчестер, иначе добавляем кучу сообщений в очередь. 
	все запросы выполняются	
	..
	идёт обработка того, что выполнилось.


