		Ян. Лекция 10.

В procinfo есть tty

tty: *FDObject
Есть char-девайс(можем работать побайтово) /dev/tty (maj 5,min 0) - такая модная штука, мы её открываем, нам выдают файловый дескриптор, который связан с FDObject. В некотором смысле это бекап файлового дескриптора.

Зачем? Допустим есть shell, вводим команду ____ | ____ | ____ ...?
И одна из команд решила попросить у нас пароль(или напечатать что-то etc)(sudo, например).
sudo обращается к tty, ему выдают файловый дескриптор терминала, в котором он и другие процессы запущены.

ps(processes)    a(all)      x(extended)

1. tty - ? - daemon(скорее всего), неинтерактивные
2. tty - что-то, какой-то fdobject - interactive(мы с ними интерактивно работаем из какого-то терминала)

По сути всё это нужно чтобы удобно было писать shell.
Мы открываем shell(процесс), он открывает новую сессию, у которой есть session id.

В procinfo добавляется sessionid, pgid. 

Есть сессия, у неё есть лидер(например bash), и в сессии есть группы процессов.
Аналогия в графическом режиме - есть оконный менеджер, который занимается окнами, обрабатывает все клавиатурные команды и прочее.
Есть лидер и pid лидера - это sid (session id) всех процессов в сессии. То же самое с группами.
setsid() - ставит в sid pid процесса, и в pgid то же самое. Нельзя сделать, если процесс является лидером своей группы. Дальше форкаемся и все процессы у нас уже живут в сессии, созданной родителем(лидером).

setpgid(pid, pgid) - ставит процессу с соответствующим pid данный pgid. Слабое ограничение - если мы находимся в той же сессии, что и чувак, которому ставим, то мы можем поставить ему pgid одной из групп этой сессии.

Теперь у нас есть сессия, в ней есть группы процессов(в каждой есть свой собственныйц лидер). Хотим обеспечить следующее: не должно произойти ситуации, когда группа процессов откололась от сессии.

Если лидер помирает, то вся сессия остаётся и помнит о нём. Не может у сессии появиться нового лидера, потому что pid остаётся занятым, пока вся секта не помрёт.

Группа процессов - это просто способ группировать процессов и не более(для того, чтобы можно было отправлять сигналы группе процессов сразу). А сессия - это какая-то модная мощная штука.

Теоретически можно попытаться дочернему процессу попытаться шлёпнуть свою собственную группу - и проблемы начинаются, если в последовательности пайпов, все, кроме одного сделали exec, а оставшийся никак не может сменить pgid. 

killpg - новый системный вызов, чтобы убить группу процессов.
А вообще kill можно указать отрицательный pid - тогда он поймёт, что это на самом деле gid группы, которую нужно убить, возьмёт по модулю и закончить группу.

Что ещё можно делать модного с группами процессов? Например, можно приделать их к одному процессору(CPU) affinity - привязать, тогда можно сэкономить на синхронизации кэша между процессами внутри группы.
shed_set_affinity - системный вызов для такого действия.
Не очень безопасно, потому что можно загрузить один процессор. Хорошая полезная штука для небольших  пайпов.

Когда делают setsid - tty удаляется. Это потому, что между сессией и tty отношение 1 к 1. Для чего это делается? В начале tty это просто были хардварные штуки. Предположим, что мы вырубили терминал, тогда шлётся сигнал HUP. Когда терминал был подключен, сигнал слался 1, а когда вырубили - напряжение у пало и стало 0. Есть терминал - магический объект - надстройка на каким-то ресурсом. Между виртуальными терминалами и старыми физическими(монитор и клавиатура + кабель до мейнфрейма) - полная аналогия.

Терминал - это тоже в некотором смысле файл - двунаправленный пайп с определёнными свойствами.

Есть процесс, который висит на терминале, и для него /dev/tty выглядит как двунаправленный пайп.
Сначала был вариант: есть ядро и несколько хардварных терминалов.
Сейчас есть ядро и несколько виртуальных терминалов и один из них в фокусе. Ядро соответствующим образом пишет в буфер, и тот выводится на монитор.

В чём супер-силы процессов, которые являются лидерами сессии(терминалов).
1. могут открывать терминалы. если то, что открывает open, является терминалом - то открывается этот терминал и становиться текущим терминалом сессии. У опен есть соответствующий флажок, чтобы он не становился текущим. Если у сессии уже есть tty и терминал - то ничего не произойдёт.

Терминал нужно открывать в самом начале создания сессии, иначе чуваки, которых мы породили до открытия терминала - они не узнают ничего о терминале и если будут делать open tty - будут получать ошибки.

Есть slave, который сам себе сессия, есть терминал - двунаправленный пайп, а по другую сторону от него - master(возможно, ядерный, или какой-то процесс). Раньше были специальны штуки, которые голым железом с этим работали. Если мастер помирает- всем чувакам в сессии приходит sig HUP (что терминал закрылся). Если лидер сессии помирает - тоже всем приходит sig HUP. 

У терминала есть размер и если размер окна изменяется, то всем процессам, которые находятся в специальной foreground- группе, приходит сигнал WINCH, чтобы они по новой отрисовали то, что в терминале.
Вся сессия - это монитор, Каждая група - это типа окно, а foreground - группа, занимающая весь монитор в текущий момент. если foreground- группа пишет что-то в терминал, оно сразу отрисовыввается. Если читают - выдаётся. Если пишет background - группа - то лидер сессии решает, что с этим делать.(можно разрешить писать, можно остановить их). Терминал буферизуется построчно. Если background - групппа хочет читать с терминала - её останавливают, потому что терминалом владеет foreground-группа и нам нельзя просто перемещать позицию.

Ctrl-Z - послать sigstop всей foreground - группе

Если мастер(клавиатура) посылает какой-то буфер ядру и в нём есть какая-то эскейп - последовательности типа Ctrl-C, то её из буфера вырезают и отправляют терминалу соответствующий этой команде сигнал.


_____

....  &disown - background - процессы, которые живут в своей, отдельной сессии. Но, тем не менее, чуваки могут работать с этим терминалам, потому что у них всё ещё есть файловые дескрипторы. Но  открыть их по новой они не смогут.

Демон: 
1. неинтерактивный процесс 
2. непосредственный потомок init-а
3. ему не приходит sigHUP как обычному процессу

Демонизация. Чтобы запустить демона нужно форкнуться, запустить процесс, парент завершается(ставит себе setsid чтобы выделиться в отдельную группу), и чилда подвешивают к init-у и у него своя сессия появляется.
Daemon - disk and execution monitor.
Для демона при посыле sig HUP - тот перечитывает свой конфиг и перезапускается.
Ctrl-H - backspace
Ctrl-W - стереть слово
Ctrl-U - стереть строку до конца
Ctrl-I - tab

Ctrl-S - замрозить
Ctrl-Q - отморозить
Ctrl-C - sigINT
Ctrl-D - eof
Ctrl-Z - sigSTOP
 
- почитать про комбинации клавиш, которые означают сигналы процессам.

если хотим написать свой zsh - читаем man openpty.

Есть такая библиотека readline - меняет character - режим работы на строчный. "Это такой маленький vim в терминале и без окна". Нужно чтобы редактировать многострочные последовательности(прыгать на позиции и прочее). Потом меняет обратно на char- режим и всё хорошо.

У неё есть общий конфиг, который можно для юзера настроить и тогда все программы, которые используют эту библиотеку, будут использовать эти настройки.

_________

Загрузка системы.
Как загружается компьютер? Всё начинается с BIOS. Блок питания всё время немножко питает материнскую плату, при нажатии кнопки включения - она говорит блоку "корми меня больше", потом измеряется напряжение, устойчивость и прочее и если всёё ок - то продолжает работу, инитит память, и запускает BIOS. 
BIOS занимается ровно тем, что настраивает систему до того уровня, чтобы операционке не нужно было знать, что именно за железки под капотом.
Нас интересует, что происходит после того, как BIOS стартовал процесс загрузки системы.

С Windows8 официально ничего поставить рядом. С этим много всякого геморроя.
Всё из-за UEFI.

Рассмотрим, что было в 80x.
Есть MBR - первые 512 байт винчестера - программа, которая начинает загружать ось. BIOS - почти операционная система, потому что она некоторые системные вызовы переопределяет в библиотечные.

Формат DOS-овский для загрузки остался более-менне неизменным. Есть несколько винчестеров, один из них BIOS считает загрузочным.
В MBR есть DOSLabel. чтобы диск был загрузочным, должны последниие два байта этих 512-ти должны быть AA55. (проверка,что каждый бит может быть установлен и в 0 и в 1).

DOSLabel - таблица из 4х элементов(записи: тип фс - флаги - байт начала фс) - разделы на диске. Если нам 4х не хватает - то расширенный - и в начале места, на который ссылается DOSLAbel - ещё один DOSLabel.
DOSLabel  - в конце MBR.

MBR - идёт по DOSLabel, находим загрузочный раздел и запускает с него. - это загрузчик DOS

В Линуксе всё по другому. Код, написанный в MBR - декодирует и запускает GRUB. GRUB делает тоже DOSlabel, тоже AA55. Между MBR и первым разделом есть пустое место - там заархивированный и закодированный ридом-соломоном код GRUB-а. В этом же пустом месте драйвера файловых систем, которые нужны, чтобы примонтировать ГРАБУ какой-то файл с конфигом. 
GRUB находит файловую систему с ядром системы(возможно, заархивированным), разархивирует его и запускает.
Что делает ядро? Сканирует устройства и т.д, пытается понять, с какого диска ей нужно загрузиться, примонтирует и запускает init;

GRUB загружает kernel, загружает initrd. 
Ядро самораспаковывается, монтирует initrd(init ramdisk) и cmdline(в сущности строчка, которую передаёт GRUB ядру - просто команда загрузки). 
Ядро инициализируется и проверяет, правда ли, что initrd есть по определённому адресу. 
Если нет - смотрит в cmdline, ищет там, можно ли загрузить то, что там написано.
Если initrd на месте, то она передаёт ему управление и тот запускает /init, который exec-ается в /sbin/init.

Как правило, /ssbin/init - скрипт на урезанной версии баша (ash), и ash загружает в ядро модули с правильными настройками. 

Самое-важное: 
initrd - tmpfs-ная файловая система, в которой есть модули чтобы примонтировать реальную корневаю фацйловую систему и вызвать init. 
initrd - нужен чтобы один и тот же образ ядра можно было запускать на разных компьютерах. То есть, при обновлении ядра OS, initrd генерируется по новой каждый для своего ядра ос(потому что в нём лежат модули ровно для этой ос).

Если мы хотим сделать общий конфиг - можно сделать огромный конфиг, который будет делать всё, но он будет занимать слишком много памяти.

В чём проблема? Есть initrd, который примонтирован в корень, мы его запустили, в какой-то момент мы хотим в корень примонтировать что-то новое, что заменит всё что сейчас в корне.
для этого нужен pivotroot, который сделает рутом определённое место, а предыдущий корень сделает поддеревом рута.

Чтобы это всё понять - имеет смысл взять archlinux и почитать в нём initrd.

Итого, последовательность загрузки: 
BIOS -> MBR(DOS/GRUB)-> ...
...(GRUB)->диск -> меюшка->(kernel ,initrd, cmdline)->...

То есть, загружается целая последовательность ядер, которые по очереди друг друга загружают.
И наконец, когда смонтирована корневая директория, запускается init.

// todo почитать tty demystified чтобы понять про tty
// extract initrd - можно почитать, что делает initrd
// man cpio

Роутеры ограничиваются initrd и в initrd находится вся система целиком.э

Большие init-ы бывают нескольких типов:

SystemV init - читает файл /etc/inittab. Там написано для каждого runlevel что нужно делать при переходе в него.
Есть понятие runlevel - состояние системы. Есть s(start), 0(выключение системы),1(однопользовательский режим)...6(перезагрузка системы) - стандартные.
Все остальные - в разных дистрибах разные.

Есть папка для каждого режима
/etc/rc{номер режима}.d/s
			k
Сначала запускаются все файлы, начинающиеся с k(kill) с аргументом stop, потом все s c аргументом(start). По сути, это скрипты которые что-то запускают/выключают. В каждой из таких папок есть одинаковые файлы, но с разными именами и в разном порядке - и этот самый порядок и определяет, в каком порядке выполняются скрипты при переходе в определённое действие. 

Минус такого инита - все скрипты запускаются последовательно, хотя, скорее всего, могли бы запускаться параллельно.
Сейчас таким редко пользуются.
______

Интересные наблюдения: 
При загрузке системы:
1. много программ можно запускать параллельно, потому что они друг о друге не знают.
2. много программ можно запускать лениво(только по требованию)
3. если есть две программы, которые друг от друга зависят, то можно написать эти программы так, чтобы дать им обоим сокет, и они писали и читали из него когда будут готовы. Тогда их можно запустить параллельно. Это называется Socket activation.
Такого рода вещи популярны на телефонах. В частности, dalvik vm.

Есть стандартные демоны, которые обычно запускаются при запуске системы.
syslog - сохраняет сообщения при запуске системы
klog - выдирает сообщения из рингбуфера ядра и кормит их syslog
ssh - удалённый shell

Есть стандартные файлы в etc:
fstab - список файловых систем, которые нужно примонтировать
mtab - там написано, что уже примонтировано
sysctl - набор переменная-значение, который загружается в ядро(константы ядра - флаги и прочая) при старте системы.
motd - печатается пользователю когда он логинится
issue - строчка, которой представляется система
nologin - файл, который если присутствует - то в систему нельзя залогиниться никому кроме рута. 
 