		Ян. Лекция 4.

есть документ со списком вопросов
План:
1. IOMMU
2. Сигналы
3. brk
4. Драйвера устройств и аппаратные механизмы для их реализации
5. drv, lib, bash, pml, hardlink
6. VFS operations

DMA - direct memory access ("девайс, сделай операцию и запиши в память - обращение к памяти наприямую из девайса") 

есть ioport - можно спросить у него, готов ли он принимать команды. Пока не готов - операционка ждёт. 
Например, есть ps-2 клавиатура. Как только в буффере клавиатуры что-то появляется - клавиатура сообщает южному мосту, что хочет 
внимания. Тот говорит северному мосту, а тот поднимает на одной из ножек прерывания процессора напряжение.
Процессор прерывает текущую команду и переставляет ip(instruction pointer) в другое место - на обработчик прерывания.
Обработчик прерывания(ipport) общается с девайсом, спрашивает, готов ли тот принимать команды, берёт оттуда данные и прочая.

DMA - способ не ждать, пока операция закончится, чтобы прочесть результат. Обработчик прерывания командует девайсу "запиши что-то в память".
Когда девайс запишет - он подаёт сигнал "я записал" и процессор снова прерывается на обработку записанного. Соответственно, процессор не 
ждёт, пока девайс что-то запишет, а занимается выполнением своих дел.

обработчик прерывания делят на две части lo и hi - hi кладёт данные в буфер, lo их обрабатывает(парсит результаты работы хай-части). ???

Можно ставить каждому девайсу свой TLB - в этом + DMA и состоит сущность IOMMU.

IOMMU - способ изолировать устройство - можно сделать виртуальное адресное пространство для девайса, чтобы тот не мог обращаться
ко всей памяти. Плюс можно целый девайс отдать виртуальной машине таким образом - смаппить с помощью TLB память виртуальной машины на память 
видеокарты и тогда видеокарта не будет знать, что с ней общается виртуальная машина.

Северный мост общается с памятью, южный - с девайсами. 

-----IOMMU

Сигналы  - предположим что процесс пытается обратиться по невалидному адресу. Можно его просто убить, но если процессор например работал с устройством, которое отвалилось(например флэшка) - то непонятно как обрабатывать такие штуки.

Для этого есть сигналы - в точности interruptы. Сигнал - адрес, который операционная система выполняет, если произошло некоторое событие(
переставляет ip). 
Сигналы - способ мапить интеррапты процессора в интеррапты userspace. 

Есть таблица обработчиков прерываний - одна на процесс, если эксепшн происходит в ОС, она мапит его в сигналы процессу или обрабатывает сама.
Первые сигналы в таблице- соответствуют хардварным интерраптам. 

-----сигналы

системный вызов brk. Program Break. "разрыв между валидной частью памяти процессора и невалидной". - по сути просто двигает указатель на
место в хипе, с которого начинает (невалидное место в хипе). Если маллок хочет выделить байт - он сначала ищет место до брейка(mmap), а если не
находит - вызывает break. 

--break

Как работают библиотеки? Есть файл программы - можно вкомпилировать в него всё и он тогда станет супер-жирным. 

Способ с этим бороться номер раз - дедуплицировать страницы при нескольких запусках. При exec - если страница уже есть в памяти - не копировать её, а пошарить.

Другой - загрузить табличку с либами после кода программы. Тогда при вызове, вызывается mmap - и код библиотеки, если она ещё не была загружена - загружается. "Там космос" - реализация очень сложная, никто не может объяснить на экзамене.

---lib


Хардлинки. Директория - табличка (имя - inode number). Хардлинки - когда несколько директорий или одна ссылается по разным именам на один файл. Симлинки можо делать между разными файловыми системами - это просто путь, а хардлинки - нельзя, потому что номера айнод локальные для файловой системы.

---hardlinks

VFS options. Namespace - список троек "префикс" - "интерейс файловой системы" - "корневая айнода" - было на прошлой паре. С неймспейсами есть 
весёлые операции. "возьми префикс и выкинь все пути, которые ему не соответствуют, а всё что начинается - замени на слэш".
эта операция называется chroot. У процесса есть указатель на namespace. mount монтирует в текущий namespace то, что попросили.

chroot - нужно, чтобы запереть процесс в директории (чтобы он не видел другой памяти, кроме одной директории). chroot сначала копирует namespace и адрес копированного модифицированного отдаёт процессу. Чтобы процесс потом поменял текущее положение для нового пути - нужен cd, тогда pwd поменяется. pwd - process working directory.

pivot_root - работает над текущим неймспесом(без копирования). 
pivot_root /mnt /etc - проверяет что в mnt есть etc. Операция отрывает всё, что есть в /mnt, а всё что снаружи /mnt - подвешивает в /etc.
Что делает - рисунок в тетради.

pivot_root нужен, чтобы переключать рут файловой системы. Юзкейс - при старте системы используется один рут где всякие драйверы, а после того,
как они отработают - делается pivot_root в нормальный рут для системы. При завершении - вызывается pivot root с обратными аргументами,
снова меняется рут и отрабатывают нужные драйвера.

есть способ создать новый namespace.
bind_mount   - монтирует директории из файловых систем, а не только сами файловые системы, как mount. Для каждого элемента монтируемого поддерева будет добавлена тройка в namespace.(чтобы два поддерева ссылались на одно и то же но с разными именами)

---------

Есть два больших способах реализовать ядро ОС - монолитный и микроядерный.
Микроядерные - "ничто не мешает разделить одни процессам делать больше, чем остальным" - мы разрешаем процессу делать всё что угодно.
В ядре находятся только штуки которые посылают сообщения между процессами. Тогда "прочесть файл" для ядра превращается в "послать сообщение определённому процессору, чтобы тот почитал файл". Микроядро только посылает сообщения. (модули хранятся в процессях)
Чем клёво? Если крэш - упадёт только один процесс и его можно перезапустить.
Плохо - нужна синхронизация при отправке сообщений, тяжело писать ход.


Монолитные(макроядерные) - ядро занимается напрямую всеми системными вызовами. (все модули хранятся в ядре)
Чем клёво - просто в реализации, не нужно думать о синхронизации при отправке сообщений, как в микроядрах. 
Плохо - если что-то покрэшилось, то падает всё ядро.

В линуксе есть "ядерный тред" - поток управления, у которого есть свой MMU, и таким образом вместо отправки сообщений - прямая передача управления, поэтому нет проблем с синхронизацией сообщений.

QNX - микроядерное ядро, которое "работает". Передач сообщений эмулирует вызов функций - вместо просто отправки сообщения - "пошли сообщение и жди пока управление вернётся обратно". То есть они эмулируют системные вызовы с помощью сообщений.
Код отвечает POSIX, разница только в сущности системного вызова.

Есть совсем микроядерные - "всё супер-асинхронно" - GNU Hurd - начали разрабатывать раньше, чем линукс - но до сих пор не работает, 20 лет пишут и не могут. 

copy on write - если обрабатываем кусок памяти - сначала делаем локальную копию.

Экзоядерная операционная система - "всё что можно рассматривать как память - будем рассматривать как память". Ядро видит винчестер, а процессы могут делать mmap прямо на винчестер. - хрень какая-то непонятная, todo погуглить

Про библиотеки - есть код, который работает в юзерспейсе, но про него операционная система гарантирует, что его не изменить - и туда отправляются вызовы, очень похожие на системные. То есть, процессы работают с библиотекой как с девайсом.

Экзоядерное ядро - ядро, при котором функции вынесены в библиотеку, а не в процессор. ?
Со всеми девайсам ядро работает напрямую как с устройствами. Всё эмулируется библиотекой - файловые дескрипторы, ФС и всё-всё-всё. 
"микроядро, под которым находится макроядро".

Преимущество - можно не использовать те абстракции, которые не нужны(можно попросить у диска просто блоки и не париться с ФС, а если хотим файловую систему - то работаем через библиотеку). 

-------------

Процессы POSIX. 

Жизнь - процессы форкаются, таким образом, порождают потомков. Всё начинается с первого процесса init - тот форкается и создаёт новые процессы.
Есть системный вызов wait(status*) - позволяет ждать, пока процесс завершиться и записывает статус завершения по месту status. 
wait(pid) - кого конкретно подождать.
Зомби-состояние - процесс завершён, записал куда-то свой код, pid-слот занят, но wait не был вызван. Зомби - "мёртвые дети, которых не ждут их родители". wait() в сущности "похоронить" процесс. 
Мораль - зомби занимают ресурсы.

Если процесс понарождал детей, а потом стал зомби - его детей можно подвесить "дедушке". Но это плохо, поэтому процессы подвешивают к init - "дом для беспризорных". а init - циклически вызывает wait у всех своих детей.
Не бывают зомбей, которые имеют детей зомбей, потому что как только появляется зомби - всех детей у него отнимают.

Треды - это процессы, у которых пошарено всё, кроме обработчиков сигналов.  Если тред породил тредов-потомков, а потом сам помер - их присоединяют к произвольному треду этого процесса. Треды в некотором смысле - "разные личности" процесса. 

В линуксе - "нету процессов, нету тредов, есть только tid - "контексты исполнения - своя память, таблица файловых дескрипторов, всё что угодно"". тиды могут объединяться в группы - эти группы и будут процессы. Внутри этой группы создаётся лидер, у которого tid, совпадающий с pid процесса. Этот tid шарит все ресурсы со своим parentом.
Лидер - такой процесс, айдишник которого используется в качестве "ещё чего-то", если он помирает, то уго айдишник не используется пока вся группа не помрёт.
Процессы - это такие штуки, которые шарят между собой ничего, треды шарят между собой обработчики ресурсов.
 
clone можно сказать, что пошарить copy on write а что нет, а форк шарит всё copy on write! Поэтому, fork() - частный случай clone().

exec() - бывает два варианта. 1. Лидер exec-ается - лидер меняет свой tid, но все дети остаются.
2. Если не лидер - происходит то же самое, но меняется tid у лидера, а все остальные tid, кроме лидера исчезают. 
















































 
